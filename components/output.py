"""
Output Component
Generates formatted output files (Markdown)
"""

import os
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional
from core.base import Output


class MarkdownOutput(Output):
    """
    Generates formatted Markdown output files
    Creates readable reports of the synthesis
    """

    def __init__(self, output_dir: Optional[str] = None, **kwargs):
        super().__init__(**kwargs)
        self.output_dir = Path(output_dir or os.getenv("DEFAULT_OUTPUT_DIR", "outputs"))
        self.output_dir.mkdir(exist_ok=True)

    def execute(self, data):
        """Execute method required by Component base class"""
        if isinstance(data, tuple):
            return self.generate(*data)
        return self.generate(data)

    def generate(self, synthesis: str, metadata: Optional[Dict] = None) -> str:
        """
        Generate a Markdown file with the synthesis

        Args:
            synthesis: The synthesized text from LLM
            metadata: Optional metadata to include in the output

        Returns:
            Path to the generated Markdown file
        """
        timestamp = datetime.now()
        timestamp_str = timestamp.strftime("%Y%m%d_%H%M%S")

        # Create filename
        if metadata and metadata.get('topic'):
            topic_slug = self._slugify(metadata['topic'])
            filename = f"{timestamp_str}_{topic_slug}.md"
        else:
            filename = f"{timestamp_str}_synthesis.md"

        filepath = self.output_dir / filename

        # Build the Markdown content
        content = self._build_markdown(synthesis, metadata, timestamp)

        # Write to file
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)

        if self.logger:
            self.logger.log_info(f"Markdown output saved: {filepath}")

        return str(filepath)

    def _build_markdown(self, synthesis: str, metadata: Optional[Dict],
                       timestamp: datetime) -> str:
        """
        Build the complete Markdown document

        Args:
            synthesis: Synthesis text
            metadata: Metadata dictionary
            timestamp: Generation timestamp

        Returns:
            Formatted Markdown string
        """
        lines = []

        # Title
        topic = metadata.get('topic', 'News Analysis') if metadata else 'News Analysis'
        lines.append(f"# {topic}\n")

        # Metadata section
        lines.append(f"**Generated:** {timestamp.strftime('%Y-%m-%d %H:%M:%S')}\n")

        if metadata:
            if metadata.get('article_count'):
                lines.append(f"**Articles Analyzed:** {metadata['article_count']}\n")

            if metadata.get('sources'):
                lines.append(f"**Sources:** {len(metadata['sources'])}\n")
                lines.append("")
                for i, source in enumerate(metadata['sources'], 1):
                    source_name = self._extract_source_name(source)
                    lines.append(f"{i}. {source_name}")
                lines.append("")

            if metadata.get('failed_sources'):
                lines.append(f"**Failed Sources:** {len(metadata['failed_sources'])}\n")
                for source in metadata['failed_sources']:
                    lines.append(f"- {source}")
                lines.append("")

        # Divider
        lines.append("---\n")

        # Main synthesis content
        lines.append(synthesis)

        # Footer
        lines.append("\n---\n")
        lines.append("*Generated by News Aggregator*\n")

        return "\n".join(lines)

    def _slugify(self, text: str, max_length: int = 50) -> str:
        """
        Convert text to a URL-safe slug

        Args:
            text: Text to slugify
            max_length: Maximum length

        Returns:
            Slugified text
        """
        import re
        slug = text.lower().strip()
        slug = re.sub(r'[^\w\s-]', '', slug)
        slug = re.sub(r'[-\s]+', '_', slug)
        return slug[:max_length]

    def _extract_source_name(self, url: str) -> str:
        """
        Extract readable name from URL

        Args:
            url: Source URL

        Returns:
            Readable source name
        """
        try:
            from urllib.parse import urlparse
            parsed = urlparse(url)
            domain = parsed.netloc or parsed.path
            domain = domain.replace('www.', '')
            parts = domain.split('.')
            return parts[0].upper() if parts else url
        except:
            return url
